import React from 'react';
import { UniversalCamera, DefaultRenderingPipeline, PointerEventTypes, FreeCamera, Vector3, HemisphericLight, MeshBuilder, GlowLayer, Color3, StandardMaterial } from "@babylonjs/core";
import SceneComponent from "src/utils/babylonjs/sceneComponent";

import Camera2DKeyboardInputs from "./camera2DKeyboardInputs";
import Camera2DMouseInputs from "./camera2DMouseInputs";

import stars from 'src/assets/galaxyData';
// import stars from 'src/assets/miniGalaxyData';

import './map.scss';

const Map = () => {
  const onSceneReady = (scene) => {
    document.getElementById("canvas").focus();
    var camera = new UniversalCamera("UniversalCamera", new Vector3(0, -1500, 0), scene);
    camera.upVector = new Vector3(0, -1, -1);

    camera.inputs.clear();
    // camera.inputs.addMouse();


    // camera.direction = new Vector3(Math.cos(camera.angle), 0, Math.sin(camera.angle));
    camera.direction = new Vector3(0, 0, 0);
    camera.angularSensibility *= -0.2;
    camera.inertia = 0;
    camera.speed = 50;
    camera.fov = 0.8;
    camera.inputs.addMouseWheel();
    camera.inputs.attached.mousewheel.wheelPrecisionY = 100;
    camera.setTarget(Vector3.Zero());

    // Disable default menu from right click
    document.oncontextmenu = function() { return false };

    const canvas = scene.getEngine().getRenderingCanvas();
    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new HemisphericLight("light", new Vector3(0, 1, 0), scene);
    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    var pipeline = new DefaultRenderingPipeline(
      "defaultPipeline", // The name of the pipeline
      true, // Do you want the pipeline to use HDR texture?
      scene, // The scene instance
      [camera] // The list of cameras to be attached to
  );

    // console.log(pipeline.depthOfField.focalLength);

    scene.useGeometryIdsMap = true;
    scene.useMaterialMeshMap = true;
    scene.useClonedMeshMap = true;
    scene.blockfreeActiveMeshesAndRenderingGroups = true;
    let originalStar = MeshBuilder.CreateSphere("star", { segments: 4, diameter: 5}, scene);
    let coreMat = new StandardMaterial("coreMat", scene);
    coreMat.emissiveColor = new Color3(.431, .627, .812); 
    originalStar.material = coreMat;
    for (let i=0; i<stars.length; i++) {
      // let star = originalStar.createInstance("star" + i);
      let star = originalStar.clone("star" + i);
      star.position.x = stars[i].x;
      star.position.y = stars[i].y;
      star.position.z = stars[i].z;
console.log(i);
      // let coreMat = new StandardMaterial("coreMat", scene);
      // coreMat.emissiveColor = new Color3(stars[i].r, stars[i].g, stars[i].b); 
      // star.material = coreMat;

      star.isPickable = true;
    };

    scene.onPointerDown = function (evt, pickResult) {
      if (pickResult.hit) {
          // console.log(pickResult);
          console.log(pickResult.pickedMesh.name);
      }
    };

    scene.blockfreeActiveMeshesAndRenderingGroups = false;
    var gl = new GlowLayer("glow", scene, {blurKernelSize: 128});
    gl.intensity = 1;
    gl.customEmissiveColorSelector = function(mesh, subMesh, material, result) {
      result.set(1, 1, 1, 0.5);
    };

    // add keyboard controls
    camera.inputs.add(new Camera2DKeyboardInputs());

    //Add mouse controls
    camera.inputs.add(new Camera2DMouseInputs());
  };

  return (
    <div className="map">
      <div className="background-opacity">
        <SceneComponent antialias onSceneReady={onSceneReady} id="canvas" tabIndex="0" />
      </div>
    </div>
  );
};

export default Map;
